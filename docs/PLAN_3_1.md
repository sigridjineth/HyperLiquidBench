Below is a drop‑in **`PLAN_3.1.md`** you can commit under `hyperliquid-bench/`.
It specifies **exact todos, data contracts, and Rust skeletons** for the **runner actions** we must support.
Where useful, I reference the prior SuiBench methodology we’re mirroring (declare metrics → execute → evaluate; Base+Bonus−Penalty), so judges see continuity with a proven design.&#x20;

---

# PLAN\_3_1.md — Runner Actions (HyperLiquidBench)

> Scope: Implement the minimum action set & artifacts so the evaluator can score coverage and HiaN.
> Target crates: `crates/hl-common`, `crates/hl-runner`.
> Outcome: One command posts orders, cancels, transfers USD‑class margin, sets leverage, **streams WS**, and writes artifacts the evaluator expects (JSONL, CSV). We keep the action surface small to finish quickly and win the **Developer Tools & Public Goods** track, with a Builder Code hook for monetization.

---

## 0) Success checklist (deliverables)

* [ ] **Perp order (post)**: side (buy/sell), `tif ∈ {ALO,GTC,IOC}`, `reduceOnly?`, `size`, `price` (absolute or `mid±%`).
* [ ] **Cancel**: by `last_oid` (session‑scoped) and by explicit OIDs.
* [ ] **USD‑class transfer**: `toPerp`, `fromPerp`.
* [ ] **Set leverage** per coin.
* [ ] **WS subscriptions**: `orderUpdates`, `fills`, `ledgerUpdates` (plus any user state). Persist snapshot & deltas → `ws_stream.jsonl`.
* [ ] **Artifacts** per run:

    * [ ] `plan.json` (+ `plan_raw.txt` if LLM used)
    * [ ] `per_action.jsonl` (one line per submitted op, with **ack** + **observed effect**)
    * [ ] `ws_stream.jsonl` (raw frames)
    * [ ] `orders_routed.csv` (`ts,oid,coin,side,px,sz,tif,reduceOnly,builder_code`)
    * [ ] `run_meta.json` (endpoint, git SHA, env, builder code, seed)
* [ ] **Time‑windowed composition** metadata: each action line includes a `submit_ts_ms` so evaluator can compute the 200 ms composition bonus.&#x20;

---

## 1) Data contracts (stable file formats)

### 1.1 `plan.json` (runner input)

Either generated by a small LLM wrapper or authored by hand for demo.

```json
{
  "steps": [
    {
      "perp_orders": {
        "orders": [
          {
            "coin": "ETH",
            "side": "buy",                 // "buy" | "sell"
            "px": "mid-1%",                // number as string OR "mid±X%"
            "sz": 0.01,
            "tif": "ALO",                  // "ALO" | "GTC" | "IOC"
            "reduceOnly": false
          }
        ],
        "builderCode": "my-code-123"       // optional
      }
    },
    { "cancel_last": {} },
    { "usd_class_transfer": { "toPerp": true, "usdc": 10.0 } },
    { "set_leverage": { "coin": "ETH", "leverage": 5 } }
  ]
}
```

### 1.2 `per_action.jsonl` (runner output; one JSON per line)

```jsonc
{
  "step_idx": 0,
  "action": "perp_orders",
  "submit_ts_ms": 1737500900123,
  "request": { /* normalized post payload */ },
  "ack": { "oid": 123456789, "coin": "ETH" },   // present for post/cancel
  "observed": {                                 // first matching WS effect within timeout
    "type": "orderAccepted|orderOpen|fill|cancelled|ledgerUpdate",
    "raw": { /* exact WS frame */ }
  },
  "window_key_ms": 1737500900000               // floor(submit_ts_ms / window) * window
}
```

### 1.3 `orders_routed.csv`

```
ts,oid,coin,side,px,sz,tif,reduceOnly,builder_code
1737500900123,123456789,ETH,buy,3501.25,0.01,ALO,false,my-code-123
```

### 1.4 `ws_stream.jsonl` (raw)

```json
{ "isSnapshot": true, "channel": "orderUpdates", "data": [ ... ] }
{ "isSnapshot": false, "channel": "fills", "data": [ ... ] }
{ "isSnapshot": false, "channel": "ledgerUpdates", "data": [ ... ] }
```

---

## 2) Cargo workspace & dependencies

* [ ] Add `hyperliquid-rust-sdk` to the workspace.
* [ ] Common deps: `tokio`, `serde`, `serde_json`, `tracing`, `dotenvy`, `thiserror`, `chrono`, `csv`.

**`Cargo.toml` (workspace root)**

```toml
[workspace]
members = ["crates/hl-common", "crates/hl-runner"]
resolver = "2"

[workspace.dependencies]
anyhow = "1"
chrono = { version = "0.4", features = ["clock"] }
csv = "1"
dotenvy = "0.15"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "time"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
# Hyperliquid SDK (pin to a tag/commit you tested)
hyperliquid-rust-sdk = { git = "https://github.com/hyperliquid-dex/hyperliquid-rust-sdk" }
```

---

## 3) `crates/hl-common` — shared types & helpers

* [ ] **Plan schema** (serde).
* [ ] **Signature builder** (for evaluator’s coverage unit).
* [ ] **Px parsing** (`"mid-1%"` → absolute).
* [ ] **Tick/lot rounding** helpers.

```rust
// crates/hl-common/src/plan.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PerpOrder {
    pub coin: String,
    pub side: Side,            // buy / sell
    pub px: PxSpec,
    pub sz: f64,
    pub tif: Tif,              // ALO / GTC / IOC
    #[serde(default)]
    pub reduce_only: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum Tif { ALO, GTC, IOC }

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Side { buy, sell }

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PxSpec {
    Abs(f64),
    Expr(String), // "mid-1%", "mid+0.25%"
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Action {
    PerpOrders { orders: Vec<PerpOrder>, #[serde(default)] builder_code: Option<String> },
    CancelLast {},
    CancelOids { oids: Vec<u64> },
    UsdClassTransfer { to_perp: bool, usdc: f64 },
    SetLeverage { coin: String, leverage: u32 },
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Plan { pub steps: Vec<Action> }
```

```rust
// crates/hl-common/src/sig.rs
pub fn signature_for_perp_order(tif: &str, reduce: bool, trigger: &str) -> String {
    format!("perp.order.{tif}:{reduce}:{trigger}") // e.g., "perp.order.ALO:false:none"
}
pub fn signature_for_cancel(scope: &str) -> String {
    format!("perp.cancel.{scope}") // "last_oid" | "explicit"
}
pub fn signature_for_usd_class(to_perp: bool) -> String {
    format!("account.usdClassTransfer.{}", if to_perp { "toPerp" } else { "fromPerp" })
}
pub fn signature_for_leverage(coin: &str) -> String {
    format!("risk.setLeverage.{coin}")
}
```

```rust
// crates/hl-common/src/px.rs
use anyhow::{anyhow, Result};

pub fn parse_mid_expr(s: &str, mid: f64) -> Result<f64> {
    // "mid-1%" or "mid+0.25%"
    let s = s.trim().to_ascii_lowercase();
    let Some(delta) = s.strip_prefix("mid") else { return Err(anyhow!("not a mid±% expr")) };
    let (sign, rest) = delta.split_at(1); // + or -
    let pct = rest.trim_end_matches('%').parse::<f64>()?;
    let abs = mid * (pct / 100.0);
    Ok(match sign {
        "+" => mid + abs,
        "-" => mid - abs,
        _ => mid,
    })
}
```

---

## 4) `crates/hl-runner` — HTTP/WS client & executor

### 4.1 CLI (one command)

```bash
cargo run -p hl-runner -- \
  --plan dataset/tasks/hl_perp_basic_01.jsonl:1 \
  --out runs/$(date +%Y%m%d-%H%M%S) \
  --endpoint-http $HL_ENDPOINT_HTTP \
  --endpoint-ws   $HL_ENDPOINT_WS \
  --builder-code  "${HL_BUILDER_CODE:-}" \
  --timeout-ms 2000
```

### 4.2 File structure

```
crates/hl-runner/
├─ src/
│  ├─ main.rs
│  ├─ client.rs        # HlHttp, HlWs
│  ├─ book.rs          # subscribe top-of-book; compute mid
│  ├─ exec.rs          # apply Plan to venue; correlate effects
│  ├─ log.rs           # writers: per_action.jsonl, ws_stream.jsonl, orders_routed.csv
│  └─ types.rs         # Ack/Effect structs, errors
```

### 4.3 WS subscriber (book + private streams)

```rust
// crates/hl-runner/src/book.rs
use serde_json::Value;
use tokio::sync::watch;

pub struct MidFeed { pub mid_rx: watch::Receiver<f64> }

pub async fn spawn_mid_feed(ws_url: &str, stream_path: &str) -> anyhow::Result<MidFeed> {
    // Connect to HL WS, subscribe to orderbook (top-of-book for coin set in plan).
    // Compute mid from best bid/ask; publish via watch channel.
    // Also write raw frames to ws_stream.jsonl through log module.
    // (Exact subscription payload depends on SDK; map it here.)
    # Ok(MidFeed { mid_rx: watch::channel(0.0).1 })
}
```

```rust
// crates/hl-runner/src/client.rs
use hyperliquid_rust_sdk as hl;
use anyhow::Result;

pub struct HlHttp { /* wrap SDK http client */ }
pub struct HlWs   { /* wrap SDK ws client */ }

impl HlHttp {
    pub async fn new(endpoint: &str, key: Option<String>, secret: Option<String>) -> Result<Self> {
        // init sdk http client
        # Ok(Self {})
    }

    pub async fn post_orders(&self, orders: Vec<PostOrderReq>) -> Result<Vec<PostOrderAck>> {
        // TODO: map to SDK call; return OIDs
        # Ok(vec![])
    }
    pub async fn cancel_oids(&self, oids: &[u64]) -> Result<()> { # Ok(()) }
    pub async fn transfer_usd(&self, to_perp: bool, usdc: f64) -> Result<()> { # Ok(()) }
    pub async fn set_leverage(&self, coin: &str, lev: u32) -> Result<()> { # Ok(()) }
}

// Normalize post payload (tick/lot rounding done before)
#[derive(Clone, Debug, serde::Serialize)]
pub struct PostOrderReq {
    pub coin: String, pub side: String, pub px: f64, pub sz: f64,
    pub tif: String, pub reduce_only: bool, pub builder_code: Option<String>,
}
#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]
pub struct PostOrderAck { pub oid: u64, pub coin: String }
```

### 4.4 Executor (plan → actions; correlation)

```rust
// crates/hl-runner/src/exec.rs
use anyhow::{Context, Result};
use chrono::Utc;
use hl_common::{plan::*, px::parse_mid_expr};
use crate::{client::*, log::*, book::MidFeed};

pub struct Executor {
    http: HlHttp,
    mid: Option<MidFeed>,
    last_oid: Option<u64>,
    logger: RunLogger,
    timeout_ms: u64,
}

impl Executor {
    pub async fn run_plan(&mut self, plan: Plan) -> Result<()> {
        for (i, step) in plan.steps.into_iter().enumerate() {
            match step {
                Action::PerpOrders { orders, builder_code } => {
                    let reqs = self.normalize_orders(orders, builder_code).await?;
                    let submit_ts = Utc::now().timestamp_millis();
                    let acks = self.http.post_orders(reqs.clone())
                        .await.context("post_orders")?;
                    // correlate first ack per OID via WS (or poll) within timeout
                    for ack in acks {
                        let effect = self.await_effect_for_oid(ack.oid).await?;
                        self.logger.log_per_action(i, "perp_orders", submit_ts, &reqs, Some(&ack), Some(&effect))?;
                        self.logger.log_routed(&ack, &reqs)?;
                        self.last_oid = Some(ack.oid);
                    }
                }
                Action::CancelLast{} => {
                    if let Some(oid) = self.last_oid {
                        let submit_ts = Utc::now().timestamp_millis();
                        self.http.cancel_oids(&[oid]).await?;
                        let effect = self.await_cancel_effect(oid).await?;
                        self.logger.log_per_action(i, "cancel_last", submit_ts, &serde_json::json!({"oid": oid}), None, Some(&effect))?;
                    }
                }
                Action::CancelOids{oids} => {
                    let submit_ts = Utc::now().timestamp_millis();
                    self.http.cancel_oids(&oids).await?;
                    let effect = self.await_cancel_effect(oids[0]).await?; // at least one
                    self.logger.log_per_action(i, "cancel_oids", submit_ts, &serde_json::json!({"oids": oids}), None, Some(&effect))?;
                }
                Action::UsdClassTransfer{to_perp, usdc} => {
                    let submit_ts = Utc::now().timestamp_millis();
                    self.http.transfer_usd(to_perp, usdc).await?;
                    let effect = self.await_ledger_delta(to_perp, usdc).await?;
                    self.logger.log_per_action(i, "usd_class_transfer", submit_ts, &serde_json::json!({"toPerp": to_perp, "usdc": usdc}), None, Some(&effect))?;
                }
                Action::SetLeverage{coin, leverage} => {
                    let submit_ts = Utc::now().timestamp_millis();
                    self.http.set_leverage(&coin, leverage).await?;
                    let effect = self.await_leverage_set(&coin, leverage).await?;
                    self.logger.log_per_action(i, "set_leverage", submit_ts, &serde_json::json!({"coin": coin, "lev": leverage}), None, Some(&effect))?;
                }
            }
        }
        Ok(())
    }

    async fn normalize_orders(&self, orders: Vec<PerpOrder>, builder_code: Option<String>)
      -> Result<Vec<PostOrderReq>> {
        let mid = if let Some(feed) = &self.mid { *feed.mid_rx.borrow() } else { 0.0 };
        let mut out = vec![];
        for o in orders {
            let px = match o.px {
                PxSpec::Abs(v) => v,
                PxSpec::Expr(expr) => parse_mid_expr(&expr, mid)?,
            };
            let px = self.round_to_tick(&o.coin, px)?;
            let sz = self.round_to_lot(&o.coin, o.sz)?;
            out.push(PostOrderReq {
                coin: o.coin,
                side: format!("{:?}", o.side), // "buy"/"sell"
                px, sz,
                tif: format!("{:?}", o.tif),   // "ALO"/"GTC"/"IOC"
                reduce_only: o.reduce_only,
                builder_code: builder_code.clone(),
            });
        }
        Ok(out)
    }

    async fn await_effect_for_oid(&self, oid: u64) -> Result<serde_json::Value> {
        // Wait for WS orderUpdate/fill containing this oid within timeout_ms
        # Ok(serde_json::json!({"type":"orderAccepted","oid":oid}))
    }
    async fn await_cancel_effect(&self, oid: u64) -> Result<serde_json::Value> {
        # Ok(serde_json::json!({"type":"cancelled","oid":oid}))
    }
    async fn await_ledger_delta(&self, to_perp: bool, usdc: f64) -> Result<serde_json::Value> {
        # Ok(serde_json::json!({"type":"ledgerUpdate","toPerp":to_perp,"usdc":usdc}))
    }
    async fn await_leverage_set(&self, coin: &str, lev: u32) -> Result<serde_json::Value> {
        # Ok(serde_json::json!({"type":"riskParam","coin":coin,"lev":lev}))
    }

    fn round_to_tick(&self, _coin: &str, px: f64) -> Result<f64> { Ok(px) /* TODO: query meta */ }
    fn round_to_lot(&self, _coin: &str, sz: f64) -> Result<f64> { Ok(sz) /* TODO: query meta */ }
}
```

### 4.5 Run logger (artifacts)

```rust
// crates/hl-runner/src/log.rs
use std::{fs::{File, create_dir_all}, path::PathBuf, io::Write};
use anyhow::Result;
use chrono::Utc;
use csv::Writer;

pub struct RunLogger {
    root: PathBuf,
    per_action: std::io::BufWriter<File>,
    ws_stream: std::io::BufWriter<File>,
    routed: Writer<File>,
    meta: File,
}

impl RunLogger {
    pub fn new(root: PathBuf) -> Result<Self> {
        create_dir_all(&root)?;
        let per_action = std::io::BufWriter::new(File::create(root.join("per_action.jsonl"))?);
        let ws_stream  = std::io::BufWriter::new(File::create(root.join("ws_stream.jsonl"))?);
        let routed_csv = Writer::from_path(root.join("orders_routed.csv"))?;
        let meta = File::create(root.join("run_meta.json"))?;
        Ok(Self { root, per_action, ws_stream, routed: routed_csv, meta })
    }
    pub fn log_per_action<T: serde::Serialize, A: serde::Serialize, O: serde::Serialize>(
        &mut self, idx: usize, action: &str, submit_ts_ms: i64, req: &T, ack: Option<&A>, obs: Option<&O>
    ) -> Result<()> {
        let window = (submit_ts_ms / 200) * 200; // default 200ms window (mirrors composition bonus window). :contentReference[oaicite:2]{index=2}
        let line = serde_json::json!({
            "step_idx": idx, "action": action, "submit_ts_ms": submit_ts_ms,
            "request": req, "ack": ack, "observed": obs, "window_key_ms": window
        });
        serde_json::to_writer(&mut self.per_action, &line)?;
        self.per_action.get_mut().write_all(b"\n")?;
        Ok(())
    }
    pub fn log_ws_raw(&mut self, v: &serde_json::Value) -> Result<()> {
        serde_json::to_writer(&mut self.ws_stream, v)?;
        self.ws_stream.get_mut().write_all(b"\n")?;
        Ok(())
    }
    pub fn log_routed(&mut self, ack: &crate::client::PostOrderAck, reqs: &[crate::client::PostOrderReq]) -> Result<()> {
        // If multiple orders submitted, write one line per ack (use matched req if needed).
        for r in reqs {
            self.routed.write_record(&[
                Utc::now().timestamp_millis().to_string(),
                ack.oid.to_string(), &ack.coin, &r.side, &format!("{}", r.px), &format!("{}", r.sz),
                &r.tif, &r.reduce_only.to_string(), r.builder_code.as_deref().unwrap_or("")
            ])?;
        }
        self.routed.flush()?;
        Ok(())
    }
    pub fn write_meta(&mut self, meta: &serde_json::Value) -> Result<()> {
        serde_json::to_writer_pretty(&mut self.meta, meta)?;
        Ok(())
    }
}
```

---

## 5) WS correlation rules (deterministic, evaluator‑friendly)

* [ ] **Order post**: treat **first** of `{orderAccepted, orderOpen, fill}` with **matching `oid`** as the observed effect.
* [ ] **Cancel**: accept `{cancelled}` with `oid` OR disappearance event for that `oid`.
* [ ] **USD transfer**: accept `ledgerUpdates` with matching delta (direction & magnitude).
* [ ] **Set leverage**: accept a risk parameter / config update event (or HTTP readback if the SDK provides it).
* [ ] **Timeout**: default **2000 ms**; if no effect arrives, record `"observed": null` and the evaluator will **no‑op filter** it to zero score.&#x20;

---

## 6) Edge‑case handling (must do)

* [ ] **Tick / lot rounding**: round passive orders toward passivity (ALO → make price strictly passive vs best quote).
* [ ] **Mid‑price dependency**: if `px="mid±%"` but mid feed not ready, **delay** up to 200 ms (retry 5× at 40 ms).
* [ ] **Builder Code**: pass through where API allows; always log it in `orders_routed.csv`.
* [ ] **Idempotency**: if HTTP returns duplicate ack for same request, dedupe by `(coin, side, px, sz, tif)` hash.
* [ ] **Threading**: single threaded `Executor` (sequential steps) to keep correlation simple for MVP.

---

## 7) Quick smoke scripts

**`scripts/run_cov.sh`**

```bash
#!/usr/bin/env bash
set -euo pipefail
OUT="runs/$(date +%Y%m%d-%H%M%S)"
cargo run -p hl-runner -- \
  --plan dataset/tasks/hl_perp_basic_01.jsonl:1 \
  --out "$OUT" \
  --endpoint-http "${HL_ENDPOINT_HTTP}" \
  --endpoint-ws   "${HL_ENDPOINT_WS}" \
  ${HL_BUILDER_CODE:+--builder-code "$HL_BUILDER_CODE"}
echo "wrote $OUT"
```

---

## 8) Validation checklist (before evaluator)

* [ ] `per_action.jsonl` contains at least one **perp\_orders** line with non‑null `ack` and an `observed` WS effect.
* [ ] For the cancel step, `observed.type == "cancelled"` (or equivalent).
* [ ] `ws_stream.jsonl` has at least one snapshot and one delta.
* [ ] `orders_routed.csv` first row shows expected columns; `builder_code` is present if provided.
* [ ] All action lines carry `submit_ts_ms` and `window_key_ms`.

---

## 9) Why this planning mirrors the proven design (for judges)

* **Step 1→4 flow** (declare metrics → deploy/plan → execute → evaluate) is the same pattern you used in SuiBench, giving reproducibility and easy CI integration.&#x20;
* **Coverage math** (Base + Bonus − Penalty with a **composition bonus** per time window) is identical in spirit—only the unit changes from “MoveCall” to **venue action signature**.&#x20;
* **No‑op filter**: any action with no observable effect scores zero, preventing gaming.&#x20;

---

## 10) Minimal test stubs (optional but fast)

```rust
// crates/hl-runner/tests/smoke.rs
use std::fs;
#[test]
fn writes_artifacts_shape() {
    // Pretend to log a couple of lines and assert schema keys exist.
    let sample = r#"{"step_idx":0,"action":"perp_orders","submit_ts_ms":1,"request":{},"ack":{"oid":1},"observed":{"type":"orderAccepted"},"window_key_ms":0}"#;
    let v: serde_json::Value = serde_json::from_str(sample).unwrap();
    assert!(v.get("submit_ts_ms").is_some());
    assert!(v.get("window_key_ms").is_some());
}
```

---

## 11) Next (time‑boxed)

* [ ] Wire the **actual** SDK calls inside `HlHttp` and WS subscription payloads in `HlWs`/`book`; test with a test key.
* [ ] Prove one run of `hl_perp_basic_01.jsonl:1` writes all artifacts.
* [ ] Hand to evaluator (coverage + HiaN).
* [ ] (If time) Add `cancel_oids` multi‑OID and `IOC reduceOnly` example for a slightly higher score spread.

---

**Footnotes**
The “Step 1–4” workflow slide, architecture diagram, and “Coverage Scoring Details (Base + Bonus − Penalty)” are reused ideas from your SuiBench deck to keep the learning curve for judges minimal and emphasize reproducibility & CI friendliness.&#x20;

---

If you want, I can also draft `domains-hl.yaml` and the first `hl_perp_basic_01.jsonl` in your repo style next.
